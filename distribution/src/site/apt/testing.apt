                                        ------
                                        Testability
                                        ------

Testing Waffle Applications

* Custom Registrars

    Waffle provides a built-in test case for verifying that your Custom Registrar (the class extending
    AbstractRegistrar) can satisfy all dependencies.  To utilize this test case extend the abstract class
    "RegistrarTest".  Here is an example of testing the HelloWorldRegistrar:

+-----+
public class HelloWorldRegistrarTest extends RegistrarTest {
    public void testDependenciesAreSatisfied() {
        assertConfiguration(HelloWorldRegistrar.class);
    }
}
+-----+

    Yep, that is all the code necessary to test your Custom Registrar.

* Actions

    Actions are extremely easy to test with JMock.  Let's write a test to verify the following:

    The "save" ActionMethod on a the AutomobileAction will save the Car being configured to a Database (via the AutomobileDAO
    interface).

    Preconditions:

        - A "Car" exists in the users session

    So here is an example of how this could be done.  We'll first write a test to ensure that the "save" ActionMethod on
    AutomobileAction does what we expect it to.

+-----+
public void AutomobileActionTest extends MockObjectTestCase {
    public void testSaveEvent() {
        Car car = new Car();

        Mock mockDAO = mock(AutomobileDAO.class); // AutomobileDAO is an interface
        mockDAO.expects(once()).method("save").with(eq(car));
        AutomobileDAO automobileDAO = (AutomobileDAO)mockDAO.proxy();

        Mock mockHttpSession = mock(HttpSession.class);
        mockHttpSession.expects(once())
            .method("getAttribute").with(eq("Car"))
            .will(retunValue(car));
        HttpSession httpSession = (HttpSession)mockHttpSession.proxy();

        AutomobileAction action = new AutomobileAction(httpSession, automobileDAO);
        action.save();
    }
}
+-----+

    So the test is first creating an instance of the Car object for use within the test.  A mock is created to stand
    in for the AutombileDAO.  We are expecting that the AutomobileDAO will have it's "save(Car):void" method called one
    time.  A mock is also created for HttpSession.  We are expecting the "getAttribute(String):Object" method to be
    called on the HttpSession mock one time, and when it is called it will return the instance of Car we have
    previously created.  Then we build the AutombileAction satisfying its dependencies with the mocks we have created
    and execute it's "save():void" method.

    Look how great this is, we can test this action in complete isolation.  No dependency on a database in order to test
    this and no need to actually have a running servlet container.  Now it is time to implement the "save():void" method
    in the AutomobileAction to satisfy our test.

+-----+
public class AutomobileAction {
    private final AutomobileDAO automobileDAO;
    private final HttpSession httpSession;

    public AutomobileAction(HttpSession httpSession, AutomobileDAO automobileDAO) {
        this.automobileAction = automobileAction;
        this.httpSession = httpSession;
    }

    public Car getCar() {
        return (Car)httpSession.getAttribute("Car");
    }

    public void save() {
        Car car = getCar();
        automobileAction.save(car);
    }
}
+-----+

    Wow, the action is pretty small and simple.  But I feel we can still improve the design.  So let's keep going with
    the Agile approach and refactor this to an even simpler solution.  Utilizing the ActionMethod firing support built
    into Waffle we can change the "save" method to expect a Car instance passed to it, therefor eliminating the dependency
    on an HttpSession.  So we will refactor the test.

+-----+
public void AutomobileActionTest extends MockObjectTestCase {
    public void testSaveEvent() {
        Car car = new Car();

        Mock mockDAO = mock(AutomobileDAO.class);
        mockDAO.expects(once()).method("save").with(eq(car));
        AutomobileDAO automobileDAO = (AutomobileDAO)mockDAO.proxy();

        AutomobileAction action = new AutomobileAction(automobileDAO);
        action.save(car);
    }
}
+-----+

    The test now only mock the AutomobileDAO exactly as it did before.  An HttpSession is no longer needed in the
    Action.  So what changed? We'll have a look at the "save" method on the Action.  It now expects an instance of a
    "Car" to be passed to it.  Running the test will cause the action to fail, so let's refactor the Action to satisfy
    the test.

+-----+
public class AutomobileAction {
    private final AutomobileDAO automobileDAO;

    public AutomobileAction(AutomobileDAO automobileDAO) {
        this.automobileAction = automobileAction;
    }

    public void save(Car car) {
        automobileAction.save(car);
    }
}
+-----+

    Now that is a pretty simple action, and no internal dependency on an HttpSession makes the test simpler too.
    Another thing to note, prior to the refactoring the AutomobileAction needed to be registered to the Session Level
    context (in the Registrar).  However after the refactoring the Action can be registered higher, to the Application
    Context Level, which will allow it to be shared across the application.

* How to test the view?

    Take a look at {{{http://www.openqa.org/selenium}Selenium}}, it allows for in browser testing.