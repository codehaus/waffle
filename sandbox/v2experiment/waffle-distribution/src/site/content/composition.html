<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
<title>Registrar</title></head>
<body>


<h2>Application Composition</h2>
<p>Now you should have an understanding of how Controllers and
ActionMethods work in Waffle and it has been mentioned that no custom
XML configuration files are needed. So how does everything get wired up?
<b>With a small java class that extends WaffleWebappComposer.</b></p>
<p>In order to register Controllers (and other components Controllers
may have dependencies on) we are required to extend the <i><a href="javadoc/core/org/codehaus/waffle/registrar/AbstractRegistrar.html">
org.codehaus.waffle.registrar.AbstractRegistrar</a></i> class. 
A Registrar class is used to register Waffle Actions and dependant components at various scopes.</p>

<textarea class="java:nogutter:nocontrols" name="code">  public class CustomRegistrar extends AbstractRegistrar {
    public CustomRegistrar(Registrar delegate) {
      super(delegate);
    }

    public void session() {
      register("shoppingCart", ShoppingCartAction.class);

      // register second and subsequent controllers or components
    }
  }
</textarea>

<p>Notice the method "session" method name? This marks the component as
'session level' within the application.</p>
<p>The registrar class name (CustomRegistrar in this case) needs to
be referenced in the <i>web.xml</i> (yes we can't completely get away
from XML if we want to play in the J2EE world).</p>

<textarea class="xml:nogutter:nocontrols" name="code">  &lt;context-param&gt;
    &lt;param-name&gt;org.codehaus.waffle.registrar.Registrar&lt;/param-name&gt;
    &lt;param-value&gt;com.thoughtworks.CustomRegistrar&lt;/param-value&gt;
  &lt;/context-param&gt;
</textarea>

<p>Let's dig deeper into how the Registrar works and what
functionality it provides. Assume we have the following three Classes in
our application.</p>
<h3>Store.java</h3>

<textarea class="java:nogutter:nocontrols" name="code">  public class Store {
    // other methods that characterize Store
  }
</textarea>

<h3>ShoppingCart.java</h3>

<textarea class="java:nogutter:nocontrols" name="code">  public class ShoppingCart {
    private Store store;

    public ShoppingCart(Store store) {
      this.store = store;
    }
    // other methods that leverage Store
  }
</textarea>

<h3>CheckoutController.java</h3>

<textarea class="java:nogutter:nocontrols" name="code">  public class CheckoutController {
    private ShoppingCart shoppingCart;

    public CheckoutController(ShoppingCart shoppingCart) {
      this.shoppingCart = shoppingCart;
    }
    // other methods that leverage ShoppingCart
  }
</textarea>

<p>With these classes one could imagine the Registrar looking
similar to:</p>

<textarea class="java:nogutter:nocontrols" name="code">  public class CustomRegistrar extends AbstractRegistrar {
    public CustomRegistrar(Registrar delegate) {
      super(delegate);
    }

    @Override
    public void application() {
      register(Store.class);
    }

    @Override
    public void session() {
      register(ShoppingCart.class);
    }

    @Override
    public void request() {
      register("checkout", CheckoutController.class);
    }
  }
</textarea>

<dl>
  <dt>NOTE:</dt>
  <dd>AbstractRegistrar also exposes to concrete registrar implementations a method to retrieve Waffle's ComponentRegistry.
This can be useful in usecases in which a custom component (registered via the <code>web.xml</code>) needs to be accessed to configure
the user business logic.</dd>
</dl>

<p>Components registered to the Application context level are shared
across all users. Session level components are shared for a user across
requests. And request level components only live as long as the request - they are garbage collected after the request.</p>
<dl>
  <dt>NOTE:</dt>
  <dd>As with any web application care must be taken to ensure data
  is stored to the correct context level.</dd>
</dl>
<p>When an application starts up and the ServletContext is
intialized your <i>CustomRegistrar.application()</i> method will be
invoked. When a session is created for a user all the <i>CustomRegistrar.session()</i>
will be invoked (that is per user and per session). When a request is
initialized the <i>CustomeRegistrar.request()</i> method will be
invoked.</p>
<p>Application level components only have access to other components
registered in the <b>application()</b> method. Session level components
can access their sibling components and those components registered
under <i>application()</i>. Request level components can access their
siblings component and their parent components (<i>session()</i>) and
grandparent components (<i>application()</i>). In other words dependency
resolution can traverse up the tree hierarchy but NOT down. The table
below describes each of the available registration method provided by
Waffle's Registrar.</p>
<table class="bodyTable">
  <tbody>
    <tr class="a">
      <td align="left"><b>Method</b></td>
      <td align="left"><b>Description</b></td>
    </tr>
    <tr class="b">
      <td align="left">application</td>
      <td align="left">will be invoked upon <b>ServletContext
      initialization</b>. This should be used for those components that need
      to live for the entire length of the application.</td>
    </tr>
    <tr class="a">
      <td align="left">session</td>
      <td align="left">will be invoked upon <b>HttpSession
      creation</b>. This should be used for those components that need to
      live for the entire length of a users session.</td>
    </tr>
    <tr class="b">
      <td align="left">request</td>
      <td align="left">will be invoked upon <b>ServletRequest
      initialization</b>. This should be used for those components that need
      to live for the entire length of a request</td>
    </tr>
  </tbody>
</table>
<p>The diagram below shows a high level view of how the levels are
seperated. As you might expect an application will have several
concurrent sessions, and a session will more than likely handle several
request (maybe not simultaneously). Of course a session from one user
cannot be accessed by a session from another user, same hold true for
requests.</p>
<img src="images/context-hierarchy.png" alt="Context level hierarchy seperation">

<p>
<b>NOTE:</b> To prevent exceptions registration of components should follow these rules:
  <ul>
    <li>key names must be unique</li>
    <li>do not register the same component multiple times</li>
    <li>ambiguous dependencies (two different implementation of an
    interface and a class dependent on a implementation)</li>
  </ul>
</p>

<p>By default the <i>"register"</i> methods cache
instances created within the framework. That is, only a single managed
instance is created. Again that is a "single managed instance"
rather than a singleton. If your application requires a new instance of
a particular component for each use you can do one of two things: first
simply register the component to the REQUEST context; or utilize the
registerNonCaching(...) method with Registrar. The registerNonCaching
method, as their name describes, will not cache and share a component
but rather a new instance of that component each time.</p>
<p>Registrar currently has the following registration methods:</p>
<table class="bodyTable">
  <tbody>
    <tr class="a">
      <td align="left"><b>Methods</b></td>
      <td align="left"><b>Description</b></td>
    </tr>
    <tr class="b">
      <td align="left"><b>Registrar useInjection(Injection injection)</b></td>
      <td align="left">Allows to change the type of Injection used, which defaults to Injection.CONSTRUCTOR.  
      Injection.SETTER is also supported</td>
    </tr>
    <tr class="b">
      <td align="left"><b>boolean isRegistered(Object typeOrInstance)</b></td>
      <td align="left">Determines if a component is already registered for a given type or instance</td>
    </tr>
    <tr class="b">
      <td align="left"><b>Object getRegistered(Object typeOrInstance)</b></td>
      <td align="left">Returns a registered component for a given type or instance.  Note that is throws a RegistrarException
      if the component is not registered or if more than one is registered for the same type.</td>
    </tr>
    <tr class="b">
      <td align="left"><b>void register(Class componentClass, Object... parameters)</b></td>
      <td align="left">Registers a component (useful for components other than Actions)</td>
    </tr>
    <tr class="a">
      <td align="left"><b>void register(Object key, Class componentClass, Object... parameters)</b></td>
      <td align="left">Register a component under a specific key (keys are used to locate Controllers from request)</td>
    </tr>
    <tr class="b">
      <td align="left"><b>void registerNonCaching(Class componentClass, Object... parameters)</b></td>
      <td align="left">Registers a component in non-caching mode, ie with new instance created for each class with the defined dependency</td>
    </tr>
    <tr class="a">
      <td align="left"><b>void registerNonCaching(Object key, Class componentClass, Object... parameters)</b></td>
      <td align="left">Registers a component in non-caching mode, ie with new instance created for each class with the defined dependency</td>
    </tr>
    <tr class="b">
      <td align="left"><b>void registerInstance(Object instance)</b></td>
      <td align="left">Registers a component instance directly</td>
    </tr>
    <tr class="a">
      <td align="left"><b>void registerInstance(Object key,  Object instance)</b></td>
      <td align="left">Registers a component instance directly under a specific key</td>
    </tr>
  </tbody>
</table>
<p>One last thing to note - we talk of CustomRegistrar here and in
some our examples, we illustrate one called MyRegistrar. It can be
called whatever you like. UserRegistrar, AdminRegistrar,
AdminActionSetup, AdminSetup are all good names if the they make sense
to you.</p>
</body></html>